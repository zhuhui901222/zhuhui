{"meta":{"title":"blog_zh","subtitle":"","description":"","author":"zhuhui","url":"http://zhuhui.club","root":"/"},"pages":[{"title":"Java","date":"2020-02-24T07:04:29.000Z","updated":"2020-02-24T07:04:30.000Z","comments":true,"path":"Java/index.html","permalink":"http://zhuhui.club/Java/index.html","excerpt":"","text":""},{"title":"Linux","date":"2020-02-24T07:04:49.000Z","updated":"2020-02-24T07:04:50.000Z","comments":true,"path":"Linux/index.html","permalink":"http://zhuhui.club/Linux/index.html","excerpt":"","text":""},{"title":"SpringBoot","date":"2020-02-24T07:06:10.000Z","updated":"2020-02-24T07:06:12.000Z","comments":true,"path":"SpringBoot/index.html","permalink":"http://zhuhui.club/SpringBoot/index.html","excerpt":"","text":""},{"title":"About","date":"2020-03-27T16:30:22.279Z","updated":"2020-03-27T16:30:22.279Z","comments":true,"path":"about/index.html","permalink":"http://zhuhui.club/about/index.html","excerpt":"","text":""},{"title":"Php","date":"2020-02-24T07:04:58.000Z","updated":"2020-02-24T07:05:00.000Z","comments":true,"path":"Php/index.html","permalink":"http://zhuhui.club/Php/index.html","excerpt":"","text":""},{"title":"Categories","date":"2020-03-26T17:45:39.814Z","updated":"2020-03-26T17:45:39.814Z","comments":true,"path":"categories/index.html","permalink":"http://zhuhui.club/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2020-03-26T17:45:39.821Z","updated":"2020-03-26T17:45:39.821Z","comments":true,"path":"tags/index.html","permalink":"http://zhuhui.club/tags/index.html","excerpt":"","text":""},{"title":"Linux","date":"2020-02-24T07:04:49.000Z","updated":"2020-02-24T07:04:50.000Z","comments":true,"path":"Java/test/test.html","permalink":"http://zhuhui.club/Java/test/test.html","excerpt":"","text":""}],"posts":[{"title":"ThreadLocal为什么会发生内存泄漏？","slug":"java/ThreadLocal为什么会发生内存泄漏？","date":"2020-04-05T06:24:00.000Z","updated":"2020-04-05T05:30:45.348Z","comments":true,"path":"2020/04/05/java/ThreadLocal为什么会发生内存泄漏？/","link":"","permalink":"http://zhuhui.club/2020/04/05/java/ThreadLocal%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F/","excerpt":"","text":"ThreadLocal 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。但是如果滥用 ThreadLocal，就可能会导致内存泄漏。下面，我们将围绕三个方面来分析 ThreadLocal 内存泄漏的问题 ThreadLocal 实现原理ThreadLocal为什么会内存泄漏ThreadLocal 最佳实践ThreadLocal 实现原理 面试官：ThreadLocal为什么会发生内存泄漏？ ThreadLocal的实现是这样的：每个Thread 维护一个 ThreadLocalMap 映射表，这个映射表的 key 是 ThreadLocal 实例本身，value 是真正需要存储的 Object。 也就是说 ThreadLocal 本身并不存储值，它只是作为一个 key 来让线程从 ThreadLocalMap 获取 value。值得注意的是图中的虚线，表示 ThreadLocalMap 是使用 ThreadLocal 的弱引用作为 Key 的，弱引用的对象在 GC 时会被回收。 ThreadLocal为什么会内存泄漏ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。 其实，ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。 但是这些被动的预防措施并不能保证不会内存泄漏： 使用static的ThreadLocal，延长了ThreadLocal的生命周期，可能导致的内存泄漏（参考ThreadLocal 内存泄露的实例分析）。分配使用了ThreadLocal又不再调用get(),set(),remove()方法，那么就会导致内存泄漏。为什么使用弱引用从表面上看内存泄漏的根源在于使用了弱引用。网上的文章大多着重分析ThreadLocal使用了弱引用会导致内存泄漏，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？ 我们先来看看官方文档的说法： To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.为了应对非常大和长时间的用途，哈希表使用弱引用的 key。 下面我们分两种情况讨论： key 使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。key 使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set,get，remove的时候会被清除。比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除。 因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。 ThreadLocal 最佳实践综合上面的分析，我们可以理解ThreadLocal内存泄漏的前因后果，那么怎么避免内存泄漏呢？ 每次使用完ThreadLocal，都调用它的remove()方法，清除数据。在使用线程池的情况下，没有及时清理ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。","categories":[{"name":"java","slug":"java","permalink":"http://zhuhui.club/categories/java/"}],"tags":[]},{"title":"","slug":"java/关于JAVA异常处理的20个最佳实践","date":"2020-03-27T16:35:23.081Z","updated":"2020-03-31T13:53:01.767Z","comments":true,"path":"2020/03/28/java/关于JAVA异常处理的20个最佳实践/","link":"","permalink":"http://zhuhui.club/2020/03/28/java/%E5%85%B3%E4%BA%8EJAVA%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%8420%E4%B8%AA%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"title: 关于JAVA异常处理的20个最佳实践tags: []categories: javadate: 2020-02-24 14:24:00异常类型这里写图片描述检查性异常(checked exceptions) 是必须在在方法的throws子句中声明的异常。它们扩展了异常，旨在成为一种“在你面前”的异常类型。JAVA希望你能够处理它们，因为它们以某种方式依赖于程序之外的外部因素。检查的异常表示在正常系统操作期间可能发生的预期问题。## 标题 ## 当你尝试通过网络或文件系统使用外部系统时，通常会发生这些异常。 大多数情况下，对检查性异常的正确响应应该是稍后重试，或者提示用户修改其输入。非检查性异常(unchecked Exceptions) 是不需要在throws子句中声明的异常。 由于程序错误，JVM并不会强制你处理它们，因为它们大多数是在运行时生成的。 它们扩展了RuntimeException。 最常见的例子是NullPointerException [相当可怕..是不是？]。 未经检查的异常可能不应该重试，正确的操作通常应该是什么都不做，并让它从你的方法和执行堆栈中出来。 在高层次的执行中，应该记录这种类型的异常。错误(errors) 是严重的运行时环境问题，几乎肯定无法恢复。 一些示例是OutOfMemoryError，LinkageError和StackOverflowError。 它们通常会让程序崩溃或程序的一部分。 只有良好的日志练习才能帮助你确定错误的确切原因。 用户自定义异常任何时候，当用户觉得他出于某种原因想要使用自己的特定于应用程序的异常时，他可以创建一个新的类来适当的扩展超类（主要是它的Exception.java）并开始在适当的地方使用它。 这些用户定义的异常可以以两种方式使用： 1) 当应用程序出现问题时，直接抛出自定义异常 throw new DaoObjectNotFoundException(“Couldn’t find dao with id “ + id);12) 或者将自定义异常中的原始异常包装并抛出 catch (NoSuchMethodException e) { throw new DaoObjectNotFoundException(“Couldn’t find dao with id “ + id, e);}123包装异常可以通过添加自己的消息/上下文信息来为用户提供额外信息，同时仍保留原始异常的堆栈跟踪和消息。 它还允许你隐藏代码的实现细节，这是封装异常的最重要原因。 现在让我们开始探索遵循行业聪明的异常处理的最佳实践。 你必须考虑并遵循的最佳做法 1) 永远不要吞下catch块中的异常catch (NoSuchMethodException e) { return null;}1232) 在你的方法里抛出定义具体的检查性异常public void foo() throws Exception { //错误方式}12一定要避免出现上面的代码示例。 它简单地破坏了检查性异常的整个目的。 声明你的方法可能抛出的具体检查性异常。 如果只有太多这样的检查性异常，你应该把它们包装在你自己的异常中，并在异常消息中添加信息。 如果可能的话，你也可以考虑代码重构。 public void foo() throws SpecificException1, SpecificException2 { //正确方式}123) 捕获具体的子类而不是捕获Exception类try { someMethod();} catch (Exception e) { //错误方式 LOGGER.error(“method has failed”, e);}12345捕获异常的问题是，如果稍后调用的方法为其方法声明添加了新的检查性异常，则开发人员的意图是应该处理具体的新异常。 如果你的代码只是捕获异常（或Throwable），你永远不会知道这个变化，以及你的代码现在是错误的，并且可能会在运行时的任何时候中断。 4) 永远不要捕获Throwable类这是一个更严重的麻烦。 因为java错误也是Throwable的子类。 错误是JVM本身无法处理的不可逆转的条件。 对于某些JVM的实现，JVM可能实际上甚至不会在错误上调用catch子句。 5) 始终正确包装自定义异常中的异常，以便堆栈跟踪不会丢失catch (NoSuchMethodException e) { throw new MyServiceException(“Some information: “ + e.getMessage()); //错误方式}123这破坏了原始异常的堆栈跟踪，并且始终是错误的。 正确的做法是： catch (NoSuchMethodException e) { throw new MyServiceException(“Some information: “ , e); //正确方式}1236) 要么记录异常要么抛出异常，但不要一起执行catch (NoSuchMethodException e) {//错误方式 LOGGER.error(“Some information”, e); throw e;}12345正如在上面的示例代码中，记录和抛出异常会在日志文件中产生多条日志消息，代码中存在单个问题，并且让尝试挖掘日志的工程师生活得很糟糕。 7) finally块中永远不要抛出任何异常try { someMethod(); //Throws exceptionOne} finally { cleanUp(); //如果finally还抛出异常，那么exceptionOne将永远丢失}12345只要cleanUp()永远不会抛出任何异常，上面的代码没有问题。 但是如果someMethod()抛出一个异常，并且在finally块中，cleanUp()也抛出另一个异常，那么程序只会把第二个异常抛出来，原来的第一个异常（正确的原因）将永远丢失。 如果你在finally块中调用的代码可能会引发异常，请确保你要么处理它，要么将其记录下来。 永远不要让它从finally块中抛出来。 8) 始终只捕获实际可处理的异常catch (NoSuchMethodException e) { throw e; //避免这种情况，因为它没有任何帮助}123这是最重要的概念。 不要为了捕捉异常而捕捉，只有在想要处理异常时才捕捉异常，或者希望在该异常中提供其他上下文信息。 如果你不能在catch块中处理它，那么最好的建议就是不要只为了重新抛出它而捕获它。 9) 不要使用printStackTrace()语句或类似的方法完成代码后，切勿忽略printStackTrace()。 你的同事可能会最终得到这些堆栈，并且对于如何处理它完全没有任何知识，因为它不会附加任何上下文信息。 10) 如果你不打算处理异常，请使用finally块而不是catch块try { someMethod(); //Method 2} finally { cleanUp(); //do cleanup here}12345这也是一个很好的做法。 如果在你的方法中你正在访问Method 2，而Method 2抛出一些你不想在method 1中处理的异常，但是仍然希望在发生异常时进行一些清理，然后在finally块中进行清理。 不要使用catch块。 11) 记住“早throw晚catch”原则这可能是关于异常处理最著名的原则。 它基本上说，你应该尽快抛出(throw)异常，并尽可能晚地捕获(catch)它。 你应该等到你有足够的信息来妥善处理它。 这个原则隐含地说，你将更有可能把它放在低级方法中，在那里你将检查单个值是否为空或不适合。 而且你会让异常堆栈跟踪上升好几个级别，直到达到足够的抽象级别才能处理问题。 12) 清理总是在处理异常之后如果你正在使用数据库连接或网络连接等资源，请确保清除它们。 如果你正在调用的API仅使用非检查性异常，则仍应使用try-finally块来清理资源。 在try模块里面访问资源，在finally里面最后关闭资源。 即使在访问资源时发生任何异常，资源也会优雅地关闭。 13) 只从方法中抛出相关异常相关性对于保持应用程序清洁非常重要。 一种尝试读取文件的方法; 如果抛出NullPointerException，那么它不会给用户任何相关的信息。 相反，如果这种异常被包裹在自定义异常中，则会更好。 NoSuchFileFoundException则对该方法的用户更有用。 14) 切勿在程序中使用流程控制异常我们已经阅读过很多次，但有时我们还是会在项目中看到开发人员尝试为应用程序逻辑而使用异常的代码。 永远不要这样做。 它使代码很难阅读，理解和丑陋。 15) 验证用户输入以在请求处理的早期捕获不利条件始终要在非常早的阶段验证用户输入，甚至在达到实际controller之前。 它将帮助你把核心应用程序逻辑中的异常处理代码量降到最低。 如果用户输入出现错误，它还可以帮助你使与应用程序保持一致。 例如：如果在用户注册应用程序中，你遵循以下逻辑： 1）验证用户2）插入用户3）验证地址4）插入地址5）如果出问题回滚一切 这是非常不正确的做法。 它会使数据库在各种情况下处于不一致的状态。 首先验证所有内容，然后将用户数据置于dao层并进行数据库更新。 正确的做法是： 1）验证用户2）验证地址3）插入用户4）插入地址5）如果问题回滚一切 16) 一个异常只能包含在一个日志中LOGGER.debug(“Using cache sector A”);LOGGER.debug(“Using retry sector B”);12不要这样做。 对多个LOGGER.debug()调用使用多行日志消息可能在你的测试用例中看起来不错，但是当它在具有400个并行运行的线程的应用程序服务器的日志文件中显示时，所有转储信息都是相同的日志文件，你的两个日志消息最终可能会在日志文件中间隔1000行，即使它们出现在代码的后续行中。 像这样做： LOGGER.debug(“Using cache sector A, using retry sector B”);117) 将所有相关信息尽可能地传递给异常有用且信息丰富的异常消息和堆栈跟踪也非常重要。 如果你的日志不能确定任何事情（有效内容不全或很难确定问题原因），那要日志有什么用？ 这类的日志只是你代码中的装饰品。 18) 终止掉被中断线程while (true) { try { Thread.sleep(100000); } catch (InterruptedException e) {} //别这样做 doSomethingCool();}123456InterruptedException是你的代码的一个提示，它应该停止它正在做的事情。 线程中断的一些常见用例是active事务超时或线程池关闭。 你的代码应该尽最大努力完成它正在做的事情，并且完成当前的执行线程，而不是忽略InterruptedException。 所以要纠正上面的例子： while (true) { try { Thread.sleep(100000); } catch (InterruptedException e) { break; }}doSomethingCool();1234567819) 使用模板方法重复try-catch在你的代码中有100个类似的catch块是没有用的。 它增加代码的重复性而且没有任何的帮助。 对这种情况要使用模板方法。 例如，下面的代码尝试关闭数据库连接。 class DBUtil{ public static void closeConnection(Connection conn){ try{ conn.close(); } catch(Exception ex){ //Log Exception - Cannot close connection } }}123456789这种类型的方法将在你的应用程序的成千上万个地方使用。 不要把这块代码放的到处都是，而是定义顶层的方法，并在下层的任何地方使用它： public void dataAccessCode() { Connection conn = null; try{ conn = getConnection(); …. } finally{ DBUtil.closeConnection(conn); }}12345678920) 在JavaDoc中记录应用程序中的所有异常把注释(javadoc)运行时可能抛出的所有异常作为一种习惯。也要尽可能包括可行的方案，用户应该关注这些异常发生的情况。 这就是我现在所想的。 如果你发现任何遗漏或你与我的观点不一致，请发表评论。 我会很乐意讨论。","categories":[{"name":"java","slug":"java","permalink":"http://zhuhui.club/categories/java/"}],"tags":[]},{"title":"java面试基础","slug":"java/java面试-基础","date":"2020-03-26T16:06:00.000Z","updated":"2020-03-27T16:51:46.930Z","comments":true,"path":"2020/03/27/java/java面试-基础/","link":"","permalink":"http://zhuhui.club/2020/03/27/java/java%E9%9D%A2%E8%AF%95-%E5%9F%BA%E7%A1%80/","excerpt":"","text":"\\1******、面向对象的特征有哪些方面**** \\1.******抽象****： 抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。 \\2.******继承****： 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。 \\3.******封装****： 封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。 \\4.** \\多态性**： 多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。","categories":[{"name":"java","slug":"java","permalink":"http://zhuhui.club/categories/java/"}],"tags":[],"author":"zhuhui"},{"title":"Hello World","slug":"hello-world","date":"2020-03-26T12:25:09.602Z","updated":"2020-02-24T02:18:50.000Z","comments":true,"path":"2020/03/26/hello-world/","link":"","permalink":"http://zhuhui.club/2020/03/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"线程池大小设置，CPU的核心数、线程数的关系和区别，同步与堵塞完全是两码事","slug":"java/线程池大小设置，CPU的核心数、线程数的关系和区别，同步与堵塞完全是两码事","date":"2020-02-29T06:26:00.000Z","updated":"2020-03-27T16:51:15.874Z","comments":true,"path":"2020/02/29/java/线程池大小设置，CPU的核心数、线程数的关系和区别，同步与堵塞完全是两码事/","link":"","permalink":"http://zhuhui.club/2020/02/29/java/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%A7%E5%B0%8F%E8%AE%BE%E7%BD%AE%EF%BC%8CCPU%E7%9A%84%E6%A0%B8%E5%BF%83%E6%95%B0%E3%80%81%E7%BA%BF%E7%A8%8B%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%A0%B5%E5%A1%9E%E5%AE%8C%E5%85%A8%E6%98%AF%E4%B8%A4%E7%A0%81%E4%BA%8B/","excerpt":"","text":"线程池应该设置多少线程合适，怎么样估算出来。最近接触到一些相关资料，现作如下总结。 最开始接触线程池的时候，没有想到就仅仅是设置一个线程池的大小居然还有这么多的学问，汗颜啊。 首先，需要考虑到线程池所进行的工作的性质： IO密集型 CPU密集型 简单的分析来看，如果是CPU密集型的任务，我们应该设置数目较小的线程数，比如CPU数目加1。如果是IO密集型的任务，则应该设置可能多的线程数，由于IO操作不占用CPU，所以，不能让CPU闲下来。当然，如果线程数目太多，那么线程切换所带来的开销又会对系统的响应时间带来影响。 在《linux多线程服务器端编程》中有一个思路，CPU计算和IO的阻抗匹配原则。 如果线程池中的线程在执行任务时，密集计算所占的时间比重为P(0&lt;P&lt;=1)，而系统一共有C个CPU，为了让CPU跑满而又不过载，线程池的大小经验公式 T = C / P。在此，T只是一个参考，考虑到P的估计并不是很准确，T的最佳估值可以上下浮动50%。 这个经验公式的原理很简单，T个线程，每个线程占用P的CPU时间，如果刚好占满C个CPU,那么必有 T * P = C。 下面验证一下边界条件的正确性： 假设C = 8，P = 1.0，线程池的任务完全是密集计算，那么T = 8。只要8个活动线程就能让8个CPU饱和，再多也没用了，因为CPU资源已经耗光了。 假设C = 8，P = 0.5，线程池的任务有一半是计算，有一半在等IO上，那么T = 16.考虑操作系统能灵活，合理调度sleeping/writing/running线程，那么大概16个“50%繁忙的线程”能让8个CPU忙个不停。启动更多的线程并不能提高吞吐量，反而因为增加上下文切换的开销而降低性能。 如果P &lt; 0.2，这个公式就不适用了，T可以取一个固定值，比如 5*C。另外公式里的C不一定是CPU总数，可以是“分配给这项任务的CPU数目”，比如在8核机器上分出4个核来做一项任务，那么C=4 文章如何合理设置线程池大小里面提到了一个公式： 1最佳线程数目 &#x3D; （（线程等待时间+线程CPU时间）&#x2F;线程CPU时间 ）* CPU数目 比如平均每个线程CPU运行时间为0.5s，而线程等待时间（非CPU运行时间，比如IO）为1.5s，CPU核心数为8，那么根据上面这个公式估算得到：((0.5+1.5)/0.5)*8=32。这个公式进一步转化为： 1最佳线程数目 &#x3D; （线程等待时间与线程CPU时间之比 + 1）* CPU数目 可以得出一个结论：线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。","categories":[{"name":"java","slug":"java","permalink":"http://zhuhui.club/categories/java/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://zhuhui.club/tags/%E7%BA%BF%E7%A8%8B/"}],"author":"zhuhui"},{"title":"readme","slug":"c++/README","date":"2020-02-24T06:24:00.000Z","updated":"2020-03-27T16:56:51.304Z","comments":true,"path":"2020/02/24/c++/README/","link":"","permalink":"http://zhuhui.club/2020/02/24/c++/README/","excerpt":"","text":"C++ 数据结构等","categories":[{"name":"c++","slug":"c","permalink":"http://zhuhui.club/categories/c/"}],"tags":[]},{"title":"readme","slug":"go/README","date":"2020-02-24T06:24:00.000Z","updated":"2020-03-27T16:56:43.243Z","comments":true,"path":"2020/02/24/go/README/","link":"","permalink":"http://zhuhui.club/2020/02/24/go/README/","excerpt":"","text":"go语言文档","categories":[{"name":"go","slug":"go","permalink":"http://zhuhui.club/categories/go/"}],"tags":[]},{"title":"readme","slug":"java/README","date":"2020-02-24T06:24:00.000Z","updated":"2020-03-27T16:56:34.018Z","comments":true,"path":"2020/02/24/java/README/","link":"","permalink":"http://zhuhui.club/2020/02/24/java/README/","excerpt":"","text":"java基础 框架 面试等文档","categories":[{"name":"java","slug":"java","permalink":"http://zhuhui.club/categories/java/"}],"tags":[]},{"title":"PHP7有哪些新功能？","slug":"php/PHP7有哪些新功能？","date":"2020-02-24T06:24:00.000Z","updated":"2020-03-27T16:55:11.746Z","comments":true,"path":"2020/02/24/php/PHP7有哪些新功能？/","link":"","permalink":"http://zhuhui.club/2020/02/24/php/PHP7%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E5%8A%9F%E8%83%BD%EF%BC%9F/","excerpt":"","text":"新功能 PHP 7增加了许多特性，其中最重要的特性如下所述 性能改进——在PHP7中合并了PHPNG代码，速度是PHP 5的两倍。 较低的内存消耗——优化的PHP 7使用较少的资源。 标量类型声明——现在可以强制执行参数和返回类型。 64位支持——对64位体系结构计算机的一致支持。 异常层次结构——异常层次结构得到改进。 许多致命错误转换为异常——异常范围增加，包括许多作为异常转换的致命错误。 安全随机数生成器——添加新的安全随机数生成器API。 已删除不推荐使用的SAPI和扩展 ——各种旧的和不支持的SAPI和扩展被从最新版本中删除。 空合并运算符(??)——添加了新的空合并运算符。 返回类型和标量类型声明——支持添加返回类型和参数类型。 匿名类——支持添加匿名。 Zero cost asserts——支持添加Zero cost asserts。 PHP 7使用新的Zend Engine 3.0来改进应用程序性能，其性能几乎是PHP 5.6的两倍，内存消耗也提高了50%。它允许在不需要任何额外硬件的情况下为更多并发用户提供服务。PHP 7是根据当前的工作负载设计和重构的。 本篇文章就是关于PHP7的介绍，希望对需要的朋友有所帮助！","categories":[{"name":"php","slug":"php","permalink":"http://zhuhui.club/categories/php/"}],"tags":[]},{"title":"readme","slug":"linux/README","date":"2020-02-24T06:24:00.000Z","updated":"2020-03-27T16:56:25.122Z","comments":true,"path":"2020/02/24/linux/README/","link":"","permalink":"http://zhuhui.club/2020/02/24/linux/README/","excerpt":"","text":"linux系统 相关文档","categories":[{"name":"linux","slug":"linux","permalink":"http://zhuhui.club/categories/linux/"}],"tags":[]},{"title":"readme","slug":"php/README","date":"2020-02-24T06:24:00.000Z","updated":"2020-03-27T16:56:07.610Z","comments":true,"path":"2020/02/24/php/README/","link":"","permalink":"http://zhuhui.club/2020/02/24/php/README/","excerpt":"","text":"php开发相关文档","categories":[{"name":"php","slug":"php","permalink":"http://zhuhui.club/categories/php/"}],"tags":[]},{"title":"手把手带你入门 Spring Security！","slug":"java/手把手带你入门-Spring-Security！","date":"2020-02-24T06:24:00.000Z","updated":"2020-03-31T13:52:40.136Z","comments":true,"path":"2020/02/24/java/手把手带你入门-Spring-Security！/","link":"","permalink":"http://zhuhui.club/2020/02/24/java/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8-Spring-Security%EF%BC%81/","excerpt":"","text":"java基础 框架 面试等文档Spring Security 是 Spring 家族中的一个安全管理框架，实际上，在 Spring Boot 出现之前，Spring Security 就已经发展了多年了，但是使用的并不多，安全管理这个领域，一直是 Shiro 的天下。 相对于 Shiro，在 SSM/SSH 中整合 Spring Security 都是比较麻烦的操作，所以，Spring Security 虽然功能比 Shiro 强大，但是使用反而没有 Shiro 多（Shiro 虽然功能没有 Spring Security 多，但是对于大部分项目而言，Shiro 也够用了）。 自从有了 Spring Boot 之后，Spring Boot 对于 Spring Security 提供了 自动化配置方案，可以零配置使用 Spring Security。 因此，一般来说，常见的安全管理技术栈的组合是这样的： SSM + ShiroSpring Boot/Spring Cloud + Spring Security注意，这只是一个推荐的组合而已，如果单纯从技术上来说，无论怎么组合，都是可以运行的。 我们来看下具体使用。 1.项目创建在 Spring Boot 中使用 Spring Security 非常容易，引入依赖即可： pom.xml 中的 Spring Security 依赖： org.springframework.boot spring-boot-starter-security 只要加入依赖，项目的所有接口都会被自动保护起来。 2.初次体验我们创建一个 HelloController: @RestControllerpublic class HelloController { @GetMapping(“/hello”) public String hello() { return “hello”; }}访问 /hello ，需要登录之后才能访问。 当用户从浏览器发送请求访问 /hello 接口时，服务端会返回 302 响应码，让客户端重定向到 /login 页面，用户在 /login 页面登录，登陆成功之后，就会自动跳转到 /hello 接口。 另外，也可以使用 POSTMAN 来发送请求，使用 POSTMAN 发送请求时，可以将用户信息放在请求头中（这样可以避免重定向到登录页面）： 通过以上两种不同的登录方式，可以看出，Spring Security 支持两种不同的认证方式： 可以通过 form 表单来认证可以通过 HttpBasic 来认证3.用户名配置默认情况下，登录的用户名是 user ，密码则是项目启动时随机生成的字符串，可以从启动的控制台日志中看到默认密码： 这个随机生成的密码，每次启动时都会变。对登录的用户名/密码进行配置，有三种不同的方式： 在 application.properties 中进行配置通过 Java 代码配置在内存中通过 Java 从数据库中加载前两种比较简单，第三种代码量略大，本文就先来看看前两种，第三种后面再单独写文章介绍，也可以参考我的微人事项目。 3.1 配置文件配置用户名/密码可以直接在 application.properties 文件中配置用户的基本信息： spring.security.user.name=javaboyspring.security.user.password=123配置完成后，重启项目，就可以使用这里配置的用户名/密码登录了。 3.2 Java 配置用户名/密码也可以在 Java 代码中配置用户名密码，首先需要我们创建一个 Spring Security 的配置类，集成自 WebSecurityConfigurerAdapter 类，如下： @Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { //下面这两行配置表示在内存中配置了两个用户 auth.inMemoryAuthentication() .withUser(“javaboy”).roles(“admin”).password(“$2a$10$OR3VSksVAmCzc.7WeaRPR.t0wyCsIj24k0Bne8iKWV1o.V9wsP8Xe”) .and() .withUser(“lisi”).roles(“user”).password(“$2a$10$p1H8iWa8I4.CA.7Z8bwLjes91ZpY.rYREGHQEInNtAp4NzL6PLKxi”); } @Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); }}这里我们在 configure 方法中配置了两个用户，用户的密码都是加密之后的字符串(明文是 123)，从 Spring5 开始，强制要求密码要加密，如果非不想加密，可以使用一个过期的 PasswordEncoder 的实例 NoOpPasswordEncoder，但是不建议这么做，毕竟不安全。 Spring Security 中提供了 BCryptPasswordEncoder 密码编码工具，可以非常方便的实现密码的加密加盐，相同明文加密出来的结果总是不同，这样就不需要用户去额外保存盐的字段了，这一点比 Shiro 要方便很多。 4.登录配置对于登录接口，登录成功后的响应，登录失败后的响应，我们都可以在 WebSecurityConfigurerAdapter 的实现类中进行配置。例如下面这样： @Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired VerifyCodeFilter verifyCodeFilter; @Override protected void configure(HttpSecurity http) throws Exception { http.addFilterBefore(verifyCodeFilter, UsernamePasswordAuthenticationFilter.class); http .authorizeRequests()//开启登录配置 .antMatchers(“/hello”).hasRole(“admin”)//表示访问 /hello 这个接口，需要具备 admin 这个角色 .anyRequest().authenticated()//表示剩余的其他接口，登录之后就能访问 .and() .formLogin() //定义登录页面，未登录时，访问一个需要登录之后才能访问的接口，会自动跳转到该页面 .loginPage(“/login_p”) //登录处理接口 .loginProcessingUrl(“/doLogin”) //定义登录时，用户名的 key，默认为 username .usernameParameter(“uname”) //定义登录时，用户密码的 key，默认为 password .passwordParameter(“passwd”) //登录成功的处理器 .successHandler(new AuthenticationSuccessHandler() { @Override public void onAuthenticationSuccess(HttpServletRequest req, HttpServletResponse resp, Authentication authentication) throws IOException, ServletException { resp.setContentType(“application/json;charset=utf-8”); PrintWriter out = resp.getWriter(); out.write(“success”); out.flush(); } }) .failureHandler(new AuthenticationFailureHandler() { @Override public void onAuthenticationFailure(HttpServletRequest req, HttpServletResponse resp, AuthenticationException exception) throws IOException, ServletException { resp.setContentType(“application/json;charset=utf-8”); PrintWriter out = resp.getWriter(); out.write(“fail”); out.flush(); } }) .permitAll()//和表单登录相关的接口统统都直接通过 .and() .logout() .logoutUrl(“/logout”) .logoutSuccessHandler(new LogoutSuccessHandler() { @Override public void onLogoutSuccess(HttpServletRequest req, HttpServletResponse resp, Authentication authentication) throws IOException, ServletException { resp.setContentType(“application/json;charset=utf-8”); PrintWriter out = resp.getWriter(); out.write(“logout success”); out.flush(); } }) .permitAll() .and() .httpBasic() .and() .csrf().disable(); }}我们可以在 successHandler 方法中，配置登录成功的回调，如果是前后端分离开发的话，登录成功后返回 JSON 即可，同理，failureHandler 方法中配置登录失败的回调，logoutSuccessHandler 中则配置注销成功的回调。 5.忽略拦截如果某一个请求地址不需要拦截的话，有两种方式实现： 设置该地址匿名访问直接过滤掉该地址，即该地址不走 Spring Security 过滤器链推荐使用第二种方案，配置如下： @Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Override public void configure(WebSecurity web) throws Exception { web.ignoring().antMatchers(“/vercode”); }}Spring Security 另外一个强大之处就是它可以结合 OAuth2 ，玩出更多的花样出来，这些我们在后面的文章中再和大家细细介绍。","categories":[{"name":"java","slug":"java","permalink":"http://zhuhui.club/categories/java/"}],"tags":[]},{"title":"verload 和 和 Override 的区 的区别。","slug":"java/Overload 和 和 Override 的区 的区别。 别。Overloaded 的方法是否可以改变返回值 的方法是否可以改变返回值","date":"2020-02-24T06:24:00.000Z","updated":"2020-03-31T13:53:50.255Z","comments":true,"path":"2020/02/24/java/Overload 和 和 Override 的区 的区别。 别。Overloaded 的方法是否可以改变返回值 的方法是否可以改变返回值/","link":"","permalink":"http://zhuhui.club/2020/02/24/java/Overload%20%E5%92%8C%20%E5%92%8C%20Override%20%E7%9A%84%E5%8C%BA%20%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82%20%E5%88%AB%E3%80%82Overloaded%20%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E8%BF%94%E5%9B%9E%E5%80%BC%20%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E8%BF%94%E5%9B%9E%E5%80%BC/","excerpt":"","text":"Overload 是重载的意思，Override 是覆盖的意思，也就是重写。重载 Overload 表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。重写 Override 表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时， 只能比父类抛 出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是 private 类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。至于 Overloaded 的方法是否可以改变返回值的类型这个问题，要看你倒底想问什么呢？这个题目很模糊。如果几个 Overloaded 的方法的参数列表不一样，它们的返回者类型当然也可以不一样。但我估计你想问的问题是：如果两个方法的参数列表完全一样，是否可以让它们的返回值不同来实现重载 Overload。这是不行的，我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用 map.remove(key)方法时，虽然 remove 方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，java 就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。override 可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达到不同的作用。对我们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型的用法以外，我们在继承中也可能会在子类覆盖父类中的方法。在覆盖要注意以下的几点：1、覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；2、覆盖的方法的返回值必须和被覆盖的方法的返回一致；3、覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；4、被覆盖的方法不能为 private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。overload 对我们来说可能比较熟悉，可以翻译为重载，它是指我们可以定义一些名称相同的方法，通过定义不同的输入参数来区分这些方法，然后再调用时，VM 就会根据不同的参数样式，来选择合适的方法执行。在使用重载要注意以下的几点：1、在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是 fun(int,float)，但是不能为 fun(int,int)）；2、不能通过访问权限、返回类型、抛出的异常进行重载；3、方法的异常类型和数目不会对重载造成影响；4、对于继承来说，如果某一方法在父类中是访问权限是 priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。","categories":[{"name":"java","slug":"java","permalink":"http://zhuhui.club/categories/java/"}],"tags":[]},{"title":"readmerrr","slug":"java/readmerrr","date":"2020-02-24T06:24:00.000Z","updated":"2020-03-31T13:51:58.487Z","comments":true,"path":"2020/02/24/java/readmerrr/","link":"","permalink":"http://zhuhui.club/2020/02/24/java/readmerrr/","excerpt":"","text":"图片来自 https://github.com/zhuhui901222/img 通过cname 转变为url ：http://img.zhuhui.club/20200328011035.jpg","categories":[{"name":"java","slug":"java","permalink":"http://zhuhui.club/categories/java/"}],"tags":[]},{"title":"go channel","slug":"go/go channel","date":"2020-02-24T06:24:00.000Z","updated":"2020-04-04T06:34:33.707Z","comments":true,"path":"2020/02/24/go/go channel/","link":"","permalink":"http://zhuhui.club/2020/02/24/go/go%20channel/","excerpt":"","text":"","categories":[{"name":"go","slug":"go","permalink":"http://zhuhui.club/categories/go/"}],"tags":[]}],"categories":[{"name":"java","slug":"java","permalink":"http://zhuhui.club/categories/java/"},{"name":"c++","slug":"c","permalink":"http://zhuhui.club/categories/c/"},{"name":"go","slug":"go","permalink":"http://zhuhui.club/categories/go/"},{"name":"php","slug":"php","permalink":"http://zhuhui.club/categories/php/"},{"name":"linux","slug":"linux","permalink":"http://zhuhui.club/categories/linux/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://zhuhui.club/tags/%E7%BA%BF%E7%A8%8B/"}]}